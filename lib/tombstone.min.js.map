{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///tombstone.min.js","webpack:///webpack/bootstrap cd385198900ddf0f3013","webpack:///./src/main.js","webpack:///./src/statement.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","Statement","undefined","_statement","_statement2","_classCallCheck","instance","Constructor","TypeError","convertToRPN","symbols","closingParen","outQueue","opStack","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","Symbol","iterator","next","done","symbol","match","push","length","pop","compareOperators","err","apply","reverse","checkWellFormed","isOperand","opening","closing","prev","isOperator","wasOperator","error","i","includes","extractSymbols","statement","accepted","split","idx","cond","bicond","extracted","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","indexOf","slice","charAt","extractvariables","variables","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","op1","op2","operators","performSubstitution","values","prepared","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","evaluate","operator","operands","RPNToTree","outStack","right","size","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","name","children","tree","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","Error","symbolsRPN","evalReady","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator"],"mappings":"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","file":"tombstone.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"tombstone\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tombstone\"] = factory();\n\telse\n\t\troot[\"tombstone\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"tombstone\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tombstone\"] = factory();\n\telse\n\t\troot[\"tombstone\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Statement = undefined;\n\t\n\tvar _statement = __webpack_require__(2);\n\t\n\tvar _statement2 = _interopRequireDefault(_statement);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.Statement = _statement2.default;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Statement = function () {\n\t  function Statement(statement) {\n\t    _classCallCheck(this, Statement);\n\t\n\t    this.symbols = extractSymbols(statement);\n\t    var error = checkWellFormed(this.symbols);\n\t    if (error) {\n\t      throw new Error(error);\n\t    }\n\t    this.statement = statement;\n\t    this.variables = extractvariables(this.statement);\n\t    this.symbols = extractSymbols(this.statement);\n\t    this.symbolsRPN = convertToRPN(this.symbols);\n\t    this.tree = RPNToTree(this.symbolsRPN);\n\t  }\n\t\n\t  _createClass(Statement, [{\n\t    key: 'evaluate',\n\t    value: function evaluate(values) {\n\t      var evalReady = performSubstitution(this.symbolsRPN, values);\n\t      var outStack = [];\n\t      var operands = [];\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = evalReady[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var symbol = _step.value;\n\t\n\t          if (typeof symbol === 'boolean') {\n\t            outStack.push(symbol);\n\t          } else {\n\t            operands.push(outStack.pop());\n\t            if (symbol !== '~') {\n\t              operands.push(outStack.pop());\n\t            }\n\t            outStack.push(_evaluate(symbol, operands));\n\t            operands = [];\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      return outStack[0];\n\t    }\n\t  }, {\n\t    key: 'variables',\n\t    value: function variables() {\n\t      return this.variables;\n\t    }\n\t  }, {\n\t    key: 'symbols',\n\t    value: function symbols() {\n\t      return this.symbols;\n\t    }\n\t  }]);\n\t\n\t  return Statement;\n\t}();\n\t\n\t/**\n\t * Uses the Shunting-Yard algorithm to convert a propositional logic statement\n\t * to Reverse Polish notation (RPN).\n\t *\n\t * @example\n\t * // [ 'P', 'Q', '<->', 'R', 'Q', '|', '&', 'S', '->' ]\n\t * convertToRPN('(P <-> Q) & (R | Q) -> S')\n\t *\n\t * @param   {String} statement - The statement to be converted.\n\t *\n\t * @returns {Array} - The statement in RPN.\n\t */\n\t\n\t\n\tfunction convertToRPN(symbols) {\n\t  var closingParen = false;\n\t  var outQueue = [];\n\t  var opStack = [];\n\t\n\t  var _iteratorNormalCompletion2 = true;\n\t  var _didIteratorError2 = false;\n\t  var _iteratorError2 = undefined;\n\t\n\t  try {\n\t    for (var _iterator2 = symbols[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t      var symbol = _step2.value;\n\t\n\t      if (symbol.match(/^[a-z]{1}$/i)) {\n\t        outQueue.push(symbol);\n\t      } else if (symbol === ')') {\n\t        closingParen = false;\n\t        while (!closingParen && opStack[opStack.length - 1] !== '(') {\n\t          outQueue.push(opStack.pop());\n\t          closingParen = opStack[opStack.length - 1] === '(';\n\t        }\n\t        opStack.pop();\n\t      } else {\n\t        while (compareOperators(symbol, opStack[opStack.length - 1])) {\n\t          outQueue.push(opStack.pop());\n\t        }\n\t        opStack.push(symbol);\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError2 = true;\n\t    _iteratorError2 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t        _iterator2.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError2) {\n\t        throw _iteratorError2;\n\t      }\n\t    }\n\t  }\n\t\n\t  outQueue.push.apply(outQueue, opStack.reverse());\n\t  return outQueue;\n\t}\n\t\n\t/**\n\t * Verify that the symbols array is valid.\n\t *\n\t * @param  {Array} symbols - The list of symbols to be checked.\n\t *\n\t * @return {String|null} - A message if an error is found and null otherwise.\n\t */\n\tfunction checkWellFormed(symbols) {\n\t  var isOperand = /^[a-z()]{1}$/i;\n\t  var opening = 0;\n\t  var closing = 0;\n\t  var symbol = null;\n\t  var prev = null;\n\t  var next = null;\n\t  var isOperator = false;\n\t  var wasOperator = false;\n\t  var error = null;\n\t\n\t  if (symbols.length === 0) {\n\t    return 'no symbols!';\n\t  }\n\t\n\t  for (var i = 0; i < symbols.length; ++i) {\n\t    symbol = symbols[i];\n\t    next = symbols[i + 1] === undefined ? '' : symbols[i + 1];\n\t    prev = symbols[i - 1] === undefined ? '' : symbols[i - 1];\n\t    isOperator = ['~', '&', '||', '->', '<->'].includes(symbol);\n\t    if (!isOperator && !symbol.match(isOperand)) {\n\t      error = 'unknown symbol!';\n\t    }\n\t    if (symbol === '(') {\n\t      opening += 1;\n\t    } else if (symbol === ')') {\n\t      closing += 1;\n\t    } else if (isOperator && wasOperator && symbol !== '~') {\n\t      error = 'double operators!';\n\t    } else if (isOperator && symbol !== '~') {\n\t      if (!prev.match(isOperand) || next !== '~' && !next.match(isOperand)) {\n\t        error = 'missing operand!';\n\t      }\n\t    } else if (symbol === '~') {\n\t      if (!next.match(isOperand)) {\n\t        error = 'missing operand!';\n\t      }\n\t    }\n\t    wasOperator = isOperator;\n\t  }\n\t\n\t  if (opening !== closing) {\n\t    error = 'unbalanced parentheses!';\n\t  } else if (symbols.length === opening + closing) {\n\t    error = 'no symbols!';\n\t  }\n\t  return error;\n\t}\n\t\n\t/**\n\t * Extract all symbols from statement.\n\t *\n\t * @example\n\t * // [ 'P', '&', '~', 'Q' ]\n\t * extractSymbols('P & ~Q')\n\t *\n\t * @example\n\t * // [ '(', 'P', '<->', 'Q', ')', '&', '(', 'R', '|', 'Q', ')', '->', 'S' ]\n\t * extractSymbols('(P<-> Q) & (R|Q) ->S')\n\t *\n\t * @param   {String} statement - The statement to be parsed.\n\t *\n\t * @returns {Array} - An array containing each symbol.\n\t */\n\tfunction extractSymbols(statement) {\n\t  var accepted = ['(', ')', '->', '&', '||', '~', '<->'];\n\t  var symbols = statement.split(' ');\n\t  var idx = 0;\n\t  var cond = null;\n\t  var bicond = null;\n\t  var extracted = [];\n\t\n\t  var _iteratorNormalCompletion3 = true;\n\t  var _didIteratorError3 = false;\n\t  var _iteratorError3 = undefined;\n\t\n\t  try {\n\t    for (var _iterator3 = symbols[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t      var symbol = _step3.value;\n\t\n\t      if (!symbol.match(/^[a-z]+$/i) && accepted.indexOf(symbol) < 0) {\n\t        idx = 0;\n\t        while (idx < symbol.length) {\n\t          cond = symbol.slice(idx, idx + 2);\n\t          bicond = symbol.slice(idx, idx + 3);\n\t          if (bicond === '<->') {\n\t            extracted.push(bicond);\n\t            idx += 3;\n\t          } else if (cond === '->' || cond === '||') {\n\t            extracted.push(cond);\n\t            idx += 2;\n\t          } else {\n\t            extracted.push(symbol.charAt(idx));\n\t            idx += 1;\n\t          }\n\t        }\n\t      } else {\n\t        extracted.push(symbol);\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError3 = true;\n\t    _iteratorError3 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t        _iterator3.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError3) {\n\t        throw _iteratorError3;\n\t      }\n\t    }\n\t  }\n\t\n\t  return extracted;\n\t}\n\t\n\t/**\n\t * Extract the variables from a given statement.\n\t *\n\t * @param   {String} statement - The statement to be considered.\n\t *\n\t * @returns {Array} - All of the variables in the given statement.\n\t */\n\tfunction extractvariables(statement) {\n\t  var symbols = extractSymbols(statement);\n\t  var variables = [];\n\t\n\t  var _iteratorNormalCompletion4 = true;\n\t  var _didIteratorError4 = false;\n\t  var _iteratorError4 = undefined;\n\t\n\t  try {\n\t    for (var _iterator4 = symbols[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t      var symbol = _step4.value;\n\t\n\t      if (symbol.match(/^[a-z]+$/i)) {\n\t        variables.push(symbol);\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError4 = true;\n\t    _iteratorError4 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t        _iterator4.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError4) {\n\t        throw _iteratorError4;\n\t      }\n\t    }\n\t  }\n\t\n\t  return variables;\n\t}\n\t\n\t/**\n\t * Compare the precedence of two operators.\n\t *\n\t * @param   {String} op1 - The first operator.\n\t * @param   {String} op2 - The second operator.\n\t *\n\t * @returns {Boolean} - true if op1 has lower precedence than op2 and false\n\t *  otherwise.\n\t */\n\tfunction compareOperators(op1, op2) {\n\t  var operators = ['~', '&', '||', '->', '<->'];\n\t  if (op2 === undefined || op2 === '(') {\n\t    return false;\n\t  }\n\t  return operators.indexOf(op1) > operators.indexOf(op2);\n\t}\n\t\n\t/**\n\t * Substitute values for symbols where possible.\n\t *\n\t * @example\n\t * // [ 'true', '&', '~', 'false' ]\n\t * performSubstitution(['P', '&', '~', 'Q'], {'P': true, 'Q': false})\n\t *\n\t * @param   {Array} symbols - The symbols to be considered.\n\t * @param   {Object} values - An object mapping symbols to their intended\n\t *  values.\n\t *\n\t * @returns {Array} - An array with symbols replaced by their values.\n\t */\n\tfunction performSubstitution(symbols, values) {\n\t  var prepared = [];\n\t\n\t  var _iteratorNormalCompletion5 = true;\n\t  var _didIteratorError5 = false;\n\t  var _iteratorError5 = undefined;\n\t\n\t  try {\n\t    for (var _iterator5 = symbols[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t      var symbol = _step5.value;\n\t\n\t      if (['(', ')', '->', '&', '||', '<->', '~'].includes(symbol)) {\n\t        prepared.push(symbol);\n\t      } else {\n\t        prepared.push(values[symbol]);\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError5 = true;\n\t    _iteratorError5 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t        _iterator5.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError5) {\n\t        throw _iteratorError5;\n\t      }\n\t    }\n\t  }\n\t\n\t  return prepared;\n\t}\n\t\n\t/**\n\t * Evaluate the given operator with its operand(s).\n\t *\n\t * @param   {String} operator - The operator to be used.\n\t * @param   {Array} operands - The operands to be used.\n\t *\n\t * @returns {Boolean} - The result of the evaluation.\n\t */\n\tfunction _evaluate(operator, operands) {\n\t  switch (operator) {\n\t    case '~':\n\t      return !operands[0];\n\t    case '&':\n\t      return operands[0] && operands[1];\n\t    case '||':\n\t      return operands[0] || operands[1];\n\t    case '->':\n\t      return !operands[1] || operands[0];\n\t    case '<->':\n\t      return operands[0] === operands[1];\n\t  }\n\t}\n\t\n\tfunction RPNToTree(symbols) {\n\t  var outStack = [];\n\t  var right = null;\n\t  var size = 0;\n\t\n\t  var _iteratorNormalCompletion6 = true;\n\t  var _didIteratorError6 = false;\n\t  var _iteratorError6 = undefined;\n\t\n\t  try {\n\t    for (var _iterator6 = symbols[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t      var symbol = _step6.value;\n\t\n\t      if (symbol.match(/^[a-z]{1}$/i)) {\n\t        outStack.push({ 'name': symbol });\n\t      } else {\n\t        right = outStack.pop();\n\t        if (symbol === '~') {\n\t          outStack.push({ 'name': symbol, 'children': [right] });\n\t        } else {\n\t          outStack.push({ 'name': symbol, 'children': [right, outStack.pop()] });\n\t        }\n\t      }\n\t      size += 1;\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError6 = true;\n\t    _iteratorError6 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t        _iterator6.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError6) {\n\t        throw _iteratorError6;\n\t      }\n\t    }\n\t  }\n\t\n\t  return { 'tree': outStack, 'size': size };\n\t}\n\t\n\texports.default = Statement;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** tombstone.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cd385198900ddf0f3013\n **/","import Statement from 'statement'\n\nexport {Statement}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/main.js\n **/","class Statement {\n  constructor (statement) {\n    this.symbols = extractSymbols(statement)\n    let error = checkWellFormed(this.symbols)\n    if (error) {\n      throw new Error(error)\n    }\n    this.statement = statement\n    this.variables = extractvariables(this.statement)\n    this.symbols = extractSymbols(this.statement)\n    this.symbolsRPN = convertToRPN(this.symbols)\n    this.tree = RPNToTree(this.symbolsRPN)\n  }\n\n  evaluate (values) {\n    const evalReady = performSubstitution(this.symbolsRPN, values)\n    let outStack = []\n    let operands = []\n\n    for (let symbol of evalReady) {\n      if (typeof symbol === 'boolean') {\n        outStack.push(symbol)\n      } else {\n        operands.push(outStack.pop())\n        if (symbol !== '~') {\n          operands.push(outStack.pop())\n        }\n        outStack.push(evaluate(symbol, operands))\n        operands = []\n      }\n    }\n\n    return outStack[0]\n  }\n\n  variables () {\n    return this.variables\n  }\n\n  symbols () {\n    return this.symbols\n  }\n}\n\n/**\n * Uses the Shunting-Yard algorithm to convert a propositional logic statement\n * to Reverse Polish notation (RPN).\n *\n * @example\n * // [ 'P', 'Q', '<->', 'R', 'Q', '|', '&', 'S', '->' ]\n * convertToRPN('(P <-> Q) & (R | Q) -> S')\n *\n * @param   {String} statement - The statement to be converted.\n *\n * @returns {Array} - The statement in RPN.\n */\nfunction convertToRPN (symbols) {\n  let closingParen = false\n  let outQueue = []\n  let opStack = []\n\n  for (let symbol of symbols) {\n    if (symbol.match(/^[a-z]{1}$/i)) {\n      outQueue.push(symbol)\n    } else if (symbol === ')') {\n      closingParen = false\n      while (!closingParen && opStack[opStack.length - 1] !== '(') {\n        outQueue.push(opStack.pop())\n        closingParen = opStack[opStack.length - 1] === '('\n      }\n      opStack.pop()\n    } else {\n      while (compareOperators(symbol, opStack[opStack.length - 1])) {\n        outQueue.push(opStack.pop())\n      }\n      opStack.push(symbol)\n    }\n  }\n\n  outQueue.push.apply(outQueue, opStack.reverse())\n  return outQueue\n}\n\n/**\n * Verify that the symbols array is valid.\n *\n * @param  {Array} symbols - The list of symbols to be checked.\n *\n * @return {String|null} - A message if an error is found and null otherwise.\n */\nfunction checkWellFormed (symbols) {\n  let isOperand = /^[a-z()]{1}$/i\n  let opening = 0\n  let closing = 0\n  let symbol = null\n  let prev = null\n  let next = null\n  let isOperator = false\n  let wasOperator = false\n  let error = null\n\n  if (symbols.length === 0) {\n    return 'no symbols!'\n  }\n\n  for (let i = 0; i < symbols.length; ++i) {\n    symbol = symbols[i]\n    next = symbols[i + 1] === undefined ? '' : symbols[i + 1]\n    prev = symbols[i - 1] === undefined ? '' : symbols[i - 1]\n    isOperator = ['~', '&', '||', '->', '<->'].includes(symbol)\n    if (!isOperator && !symbol.match(isOperand)) {\n      error = 'unknown symbol!'\n    }\n    if (symbol === '(') {\n      opening += 1\n    } else if (symbol === ')') {\n      closing += 1\n    } else if (isOperator && wasOperator && symbol !== '~') {\n      error = 'double operators!'\n    } else if (isOperator && symbol !== '~') {\n      if (!prev.match(isOperand) || (next !== '~' && !next.match(isOperand))) {\n        error = 'missing operand!'\n      }\n    } else if (symbol === '~') {\n      if (!next.match(isOperand)) {\n        error = 'missing operand!'\n      }\n    }\n    wasOperator = isOperator\n  }\n\n  if (opening !== closing) {\n    error = 'unbalanced parentheses!'\n  } else if (symbols.length === (opening + closing)) {\n    error = 'no symbols!'\n  }\n  return error\n}\n\n/**\n * Extract all symbols from statement.\n *\n * @example\n * // [ 'P', '&', '~', 'Q' ]\n * extractSymbols('P & ~Q')\n *\n * @example\n * // [ '(', 'P', '<->', 'Q', ')', '&', '(', 'R', '|', 'Q', ')', '->', 'S' ]\n * extractSymbols('(P<-> Q) & (R|Q) ->S')\n *\n * @param   {String} statement - The statement to be parsed.\n *\n * @returns {Array} - An array containing each symbol.\n */\nfunction extractSymbols (statement) {\n  const accepted = ['(', ')', '->', '&', '||', '~', '<->']\n  const symbols = statement.split(' ')\n  let idx = 0\n  let cond = null\n  let bicond = null\n  let extracted = []\n\n  for (let symbol of symbols) {\n    if (!symbol.match(/^[a-z]+$/i) && accepted.indexOf(symbol) < 0) {\n      idx = 0\n      while (idx < symbol.length) {\n        cond = symbol.slice(idx, idx + 2)\n        bicond = symbol.slice(idx, idx + 3)\n        if (bicond === '<->') {\n          extracted.push(bicond)\n          idx += 3\n        } else if (cond === '->' || cond === '||') {\n          extracted.push(cond)\n          idx += 2\n        } else {\n          extracted.push(symbol.charAt(idx))\n          idx += 1\n        }\n      }\n    } else {\n      extracted.push(symbol)\n    }\n  }\n\n  return extracted\n}\n\n/**\n * Extract the variables from a given statement.\n *\n * @param   {String} statement - The statement to be considered.\n *\n * @returns {Array} - All of the variables in the given statement.\n */\nfunction extractvariables (statement) {\n  const symbols = extractSymbols(statement)\n  let variables = []\n\n  for (let symbol of symbols) {\n    if (symbol.match(/^[a-z]+$/i)) {\n      variables.push(symbol)\n    }\n  }\n\n  return variables\n}\n\n/**\n * Compare the precedence of two operators.\n *\n * @param   {String} op1 - The first operator.\n * @param   {String} op2 - The second operator.\n *\n * @returns {Boolean} - true if op1 has lower precedence than op2 and false\n *  otherwise.\n */\nfunction compareOperators (op1, op2) {\n  const operators = ['~', '&', '||', '->', '<->']\n  if (op2 === undefined || op2 === '(') {\n    return false\n  }\n  return operators.indexOf(op1) > operators.indexOf(op2)\n}\n\n/**\n * Substitute values for symbols where possible.\n *\n * @example\n * // [ 'true', '&', '~', 'false' ]\n * performSubstitution(['P', '&', '~', 'Q'], {'P': true, 'Q': false})\n *\n * @param   {Array} symbols - The symbols to be considered.\n * @param   {Object} values - An object mapping symbols to their intended\n *  values.\n *\n * @returns {Array} - An array with symbols replaced by their values.\n */\nfunction performSubstitution (symbols, values) {\n  let prepared = []\n\n  for (let symbol of symbols) {\n    if (['(', ')', '->', '&', '||', '<->', '~'].includes(symbol)) {\n      prepared.push(symbol)\n    } else {\n      prepared.push(values[symbol])\n    }\n  }\n\n  return prepared\n}\n\n/**\n * Evaluate the given operator with its operand(s).\n *\n * @param   {String} operator - The operator to be used.\n * @param   {Array} operands - The operands to be used.\n *\n * @returns {Boolean} - The result of the evaluation.\n */\nfunction evaluate (operator, operands) {\n  switch (operator) {\n    case '~':\n      return !operands[0]\n    case '&':\n      return operands[0] && operands[1]\n    case '||':\n      return operands[0] || operands[1]\n    case '->':\n      return !operands[1] || operands[0]\n    case '<->':\n      return operands[0] === operands[1]\n  }\n}\n\nfunction RPNToTree (symbols) {\n  let outStack = []\n  let right = null\n  let size = 0\n\n  for (let symbol of symbols) {\n    if (symbol.match(/^[a-z]{1}$/i)) {\n      outStack.push({'name': symbol})\n    } else {\n      right = outStack.pop()\n      if (symbol === '~') {\n        outStack.push({'name': symbol, 'children': [right]})\n      } else {\n        outStack.push({'name': symbol, 'children': [right, outStack.pop()]})\n      }\n    }\n    size += 1\n  }\n\n  return {'tree': outStack, 'size': size}\n}\n\nexport default Statement\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/statement.js\n **/"],"sourceRoot":""}